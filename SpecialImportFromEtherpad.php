<?php
/**
 * Extension that adds ability to create wiki pages from etherpads.
 * See https://github.com/christi3k/ImportFromEtherpad for more information.
 * Copyright (C) 2015 Christie Koehler <ck@christi3k.net>
 *
 * @section LICENSE
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 * @file
 * @ingroup Extensions
 */

/**
 * This is the main class of the ImportFromEtherpad extension. 
 *
 * @ingroup Extensions
 */
class SpecialImportFromEtherpad extends SpecialPage {

	/**
	 * Array that collects any errors generated by script.
	 * @var array $errors
	 */
	private $errors = array();

	/**
	 * Array that collects any errors generated by script.
	 * @var array $formErrors
	 */
	private $formErrors = array();

	/** 
	 * Constructor for Special page.
	 *
	 */
	public function __construct() {
		global $wgImportFromEtherpadSettings;
		parent::__construct('ImportFromEtherpad', 'edit');
		$this->pathToPandoc = $wgImportFromEtherpadSettings->pathToPandoc;
		$this->pandocCmd = $wgImportFromEtherpadSettings->pandocCmd;
		$out = $this->getOutput();
		$out->addHTML('<div style="border: 1px solid black; padding: 5px; background: orange; font-weight: bold; font-size: 1.2em;">Thank you for helping to test this extension. Please report any issues <a href="https://github.com/christi3k/ImportFromEtherpad/issues">on Github</a>. If you have quesetions, feel free to ask the developer (<a href="https://mozillians.org/u/ckoehler/">ckoehler</a>) via irc or email.</div>');
	}

	/**
	 * Show special page
	 *
	 * @param mixed $par Parameter passed to the page
	 * @throws PermissionsError
	 * @return void
	 */
	public function execute( $par ) {
		// @todo verify this is in the right place and used correctly
		$this->checkReadOnly();

		$this->setHeaders();
		$this->outputHeader();

		$out = $this->getOutput();

		// allow only users with edit permissons to access
		$user = $this->getUser();
		if ( !$user->isAllowedAny( 'edit' ) ) {
			throw new PermissionsError( 'createpage' );
		}

		$out->addWikiMsg('importfrometherpad-intro');
		$request = $this->getRequest();
		// if formsubmitted, process the request
		if ($request->wasPosted() && $request->getVal('action') == 'submit') {
			$this->loadRequest();
		}
		else {
			$this->displayForm();
		}
		// either way display the form
		// if unprocessed, basic form will be shown
		// otherwise will display with errors and/or result of import
	}

	/**
	 * Determins where this specialpage is listed on Special:SpecialPages
	 *
	 * @return string name of specialpages section
	 */
	protected function getGroupName() {
		return 'pagetools';
	}

	/**
	 * display the import form
	 *
	 * @param array $errors Array of errors generated by previous form submission
	 * @return void
	 */
	private function displayForm( $errors = array() ) {
		$message = '';
		$action = $this->getPageTitle()->getLocalURL(array('action'=>'submit'));
		$out = $this->getOutput();
		$user = $this->getUser();

		$request = $this->getRequest();

		// get values from request object
		$this->etherpadLink= $request->getText('etherpadLink');
		$this->targetpageTitle = $request->getText('targetpageTitle');
		$this->targetpageNs = $request->getIntOrNull('targetpageNs');

		if ( count ( $errors ) == 1 && isset ( $errors[0][0] ) && $errors[0][0] == 'targetpage-exists') {
				// add radio buttons to prompt for replace or append
				$appendOrReplaceRadio = "<tr><td colspan='2'><strong>".$this->msg('importfrometherpad-append-or-replace-label')."</strong></td></tr>";
				$appendOrReplaceRadio .= "<tr><td></td>";
				$appendOrReplaceRadio .= "<td class='mw-submit'>";
				$appendOrReplaceRadio .= Xml::radioLabel($this->msg('importfrometherpad-append-btn')->text(), 'pageAppendOrReplace', 'append', 'mw-append');
				$appendOrReplaceRadio .= Xml::radioLabel($this->msg('importfrometherpad-replace-btn')->text(), 'pageAppendOrReplace', 'replace', 'mw-replace');
				$appendOrReplaceRadio .= "</td></tr>";
				$errors = array();
		} else {
				$appendOrReplaceRadio = '';
		}

		// display all errors
		if( count ($errors) > 0 ){
			foreach($errors as $error) {
				$out->addHTML('<div class="error">'.$this->msg($error)->text().'</div>');
			}
		}

		// make sure user is allowed to create pages and if yes, show import form
		if ( $user->isAllowed( 'createpage' ) ) {
			$out->addHTML(
				Xml::fieldset($this->msg('importfrometherpad-fieldset-legend')->text()) .
				Xml::openElement(
					'form', array(
						'method' => 'post',
						'action' => $action,
						'id' => 'importfrometherpad-form'
					)
				) .
				$this->msg('importfrometherpad-text')->parseAsBlock() .
				Html::hidden('action', 'submit') .
				Xml::openElement('table',array('id'=>'importfrometherpad-table')) .
				"<tr><td class='mw-label'>" .
				Xml::label($this->msg('importfrometherpad-label-eplink')->text(), 'mw-eplink') .
				"</td>" .
				"<td class='mw-input'>" .
				Xml::input('etherpadLink', 50, ($this->etherpadLink), array('id' => 'mw-eplink', 'type'=>'text')) .
				"</td></tr>" .
				"<tr><td class='mw-label'>" .
				Xml::label($this->msg('importfrometherpad-label-targetpage')->text(), 'mw-targetpage') .
				"</td>" .
				"<td class='mw-input'>" .
				Html::namespaceSelector(
					array(
						'selected' => ($this->targetpageNs ? $this->targetpageNs : NS_MAIN)
					),
					array('name' => 'targetpageNs', 'id' => 'mw-targetpage-ns')
				) .
				Xml::input('targetpageTitle', 50, $this->targetpageTitle, array('id' => 'mw-targetpage', 'type'=>'text')) .
				"</td></tr>" .
				$appendOrReplaceRadio .
				"<tr><td></td>" .
				"<td class='mw-submit'>" .
				Xml::submitButton($this->msg('importfrometherpad-submitbtn')->text(), array('id' => 'importfrometherpad-submit')) .
				"</td></tr>" .
				Xml::closeElement('table') . 
				Html::hidden( 'editToken', $user->getEditToken() ) .
				Xml::closeElement('form') . 
				Xml::closeElement('fieldset')
			);
		} else {
			$out->addWikiMsg('importfrometherpad-nopermission');
		}
	}

	/**
	 * Process the import request
	 *
	 * @throws PermissionsError
	 * @return void
	 */
	protected function loadRequest() {
		$request = $this->getRequest();
		$user = $this->getUser();

		// get values from request object
		// @todo make this an array so we can iterate on it
		$this->etherpadLink= trim($request->getText('etherpadLink'));
		$this->targetpageTitle = trim($request->getText('targetpageTitle'));
		$this->targetpageNs = $request->getIntOrNull('targetpageNs');
		$this->pageAppendOrReplace = $request->getVal('pageAppendOrReplace');

		// grab output object
		// https://doc.wikimedia.org/mediawiki-core/REL1_23/php/html/classSpecialPage.html#a1dd08360c4383ac5aff17107da7b2cd5
		$output = $this->getOutput();

		// initiate status object
		// use built-in status tracking 
		// https://doc.wikimedia.org/mediawiki-core/master/php/html/classStatus.html
		$this->result = new Status;

		// check edit token
		$this->token = $user->getEditToken();
		if ( !$user->matchEditToken( $request->getVal( 'editToken' ) ) ) {
			$this->result->fatal('import-token-mismatch');
		} 
		
		//check permissions
		if ( !$user->isAllowed( 'createpage' ) ) {
			throw new PermissionsError( 'createpage' );
		}

		// initiate exception var
		$exception = false;

		// try the import and catch any exceptions
		try {
			$importResult = $this->importEtherpad();
		} catch ( MWException $e ) {
			$exception = $e;
		}

		// now format output, starting with exceptions
		if ( $exception ) {
			// @todo use our own messages for this?
			$output->wrapWikiMsg(
				"<p class=\"error\">\n$1\n</p>",
				array( 'importfailed', $exception->getMessage() )
			);
		} elseif ( !$this->result->isGood() ) {
			//show any fatal errors that are not exceptions
			// @todo use our own messages for this?
			$output->wrapWikiMsg(
				"<p class=\"error\">\n$1\n</p>",
				array( 'importfailed', $this->result->getWikiText() )
			);
			//$this->displayForm();
		} else if ( !$importResult) {
			//$this->displayForm($this->formErrors);
		} else {
			// show success!
			$output->addWikiMsg( 'importfrometherpad-importsuccess' );
			if (isset($this->resultMessage)) {
				$output->addWikiMsg( $this->resultMessage );
			}
			$newLink = Linker::linkKnown($this->newTitle);
			$output->addHTML( $this->msg( 'importfrometherpad-newlink' )->rawParams( $newLink )->parseAsBlock() );

			// now clear request vars so form is re-displayed without previous input
			$request->unsetVal('etherpadLink');
			$request->unsetVal('targetpageTitle');
			$request->unsetVal('targetpageNs');
			$request->unsetVal('pageAppendOrReplace');

			// reset form errors array
			$this->formErrors = array();
		}
		//$output->addHTML( '<hr />' );

		// always re-display form after loading request
		// if there are errors or other messages, form will show them
		$this->displayForm($this->formErrors);
	}

	/**
	 * Retrives content from etherpad and converts to mediawiki syntax if necessary.
	 * Function first tries to retrieve mediawiki export, if that fails html.
	 * Fatal errors are set in $this->result, a mw status object.
	 * If article is successfully converted and saved, specific outcome
	 * is recorded in $this->resultMessage.
	 *
	 * @return bool True if import is succesful, otherwise false.
	 *
	 */
	private function importEtherpad() {
		// check validity of ep url
		// right now this just checks to make sure it's a valid URI
		// @todo investigate if there is a way to check for valid ep instance
		if ( !Http::isValidURI($this->etherpadLink) ) {
			$this->result->fatal('importfrometherpad-invalidetherpad');
			return false;
		}

		// is the pad public?
		if ( !$this->isPadPublic($this->etherpadLink) ) {
			$this->result->fatal('importfrometherpad-privatepad');
			return false;
		}

		// check validity of targettitle
		// @todo check permissions if attempting to use namespaces?
		$this->newTitle = Title::makeTitleSafe($this->targetpageNs, $this->targetpageTitle);
		if ( is_null($this->newTitle) ) {
			$this->result->fatal( 'importfrometherpad-invalidpagetitle' );
			return false;
		}

		// does the target page already exist?
		// and has the user not already indicated we should append/or replace?
		if ( $this->newTitle->exists() && !isset($this->pageAppendOrReplace) ) {
			$this->formErrors = array( array( 'targetpage-exists' ) );
			return false;
		}

		// convert content
		// all the work of Pandoc converting from html to wikimarkup is here
		if ( !$this->convertContent() ) {
			$this->result->fatal( 'importfrometherpad-fail' );
			return false;
		}

		// save article
		$apiResult = $this->saveArticle();

		// now check results of save and set result message and return value accordingly
		if ( isset( $apiResult['edit'] ) && $apiResult['edit']['result'] == 'Success' ){
			if ( isset( $apiResult['edit']['new'] ) ) {
				$this->resultMessage = 'importfrometherpad-sucessful-new';
			}
			else if ( isset( $apiResult['edit']['oldrevid'] ) && $apiResult['edit']['oldrevid'] == 0 ) {
				$this->resultMessage = 'importfrometherpad-sucessful-update';
			}
			else if ( isset( $apiResult['edit']['nochange'] ) ) {
				$this->resultMessage = 'importfrometherpad-sucessful-nochange';
			}
			$this->result->setResult(true);
			return true;
		} else {
			$this->result->fatal( 'importfrometherpad-savefail' );
			return false;
		}
	}

	/**
	 * Save converted etherpad content as a wiki page. Uses Mediawiki API.
	 *
	 * @return array ApiResult data array
	 */
	private function saveArticle() {
		// set whether or not we're creting/editing article with new content (text) 
		// or appending to an existing one (text)
		$textOrAppendText = ( isset( $this->pageAppendOrReplace ) && $this->pageAppendOrReplace == 'append') ? 'appendtext' : 'text';
		// action for both page edit and create is 'edit'
		// https://www.mediawiki.org/wiki/API:Edit
		$action = 'edit';
		// @todo localize comment text, including link to specialpage?
		$comment = 'Page generated from '. $this->etherpadLink . ' by [[Special:ImportFromEtherpad]]';
        $api = new ApiMain(
                new DerivativeRequest(
                $this->getRequest(), // Fallback upon $wgRequest if you can't access context
                array(
            'action' => $action,
            'title' => $this->newTitle,
            $textOrAppendText => $this->content, // can only use one of 'text' or 'appendtext'
            'summary' => $comment,
            'notminor' => true,
            'token' => $this->token
                ), true // was posted?
                ), true // enable write?
        );
		$api->execute(); // actually save the article.
		$apiResult = $api->getResult()->getData();
		// get and return apiResult object
		return $api->getResult()->getData();
	}

	/**
	 * Retreives and converts etherpad content, if necessary.
	 * Stores content in $this->content
	 *
	 * @return bool result of retrival and conversion
	 */
	private function convertContent()
	{
		// need this to retrieve user-specified conv regexes
		global $wgImportFromEtherpadSettings;

		// derive the export url from etherpad url
		$exportUrl = $this->getExportUrl();
		if ($exportUrl === false) {
			// @todo set user-facing error message
			return false;
		}

		if ( $exportUrl['scheme'] == 'lite-mediawiki' ) {
			// already mediawiki so no need to run through pandoc,
			// just go get it
			$this->content = $this->fetchContent( $exportUrl['url'] );
			if ( !$this->content) { return false; }
		}
		else {
			$returnVal = $this->convertWithPandoc( $exportUrl );

			if ( $returnVal !== 0 ) {
				$this->formErrors[] = array( 'importfrometherpad-pandocerror' );
				return false;
			}

			// @todo should prob move to a helper function
			if ( isset($wgImportFromEtherpadSettings->contentRegexs) ) {
				foreach ($wgImportFromEtherpadSettings->contentRegexs as $regex) {
					$this->content = preg_replace("/{$regex[0]}/mu", "{$regex[1]}", $this->content);
				}
			}
		}
		return true;
	}

	/**
	 * Takes user-facing etherpad url and determines valid export url, if it can find one.
	 *
	 * @return mixed array of url and scheme, otherwise false
	 */
	private function getExportUrl()
	{
		$parsedUrl = parse_url($this->etherpadLink);
		// build an array of possible valid etherpad export urls
		// in order of preference
		$schemes = array();

		// check for revision-specific url (ep classic only)
		// and set schema accordingly
		if ( preg_match("#/ep/pad/view/#" , $parsedUrl['path']) ) {
			$parsedUrl['path'] = preg_replace("#/ep/pad/view/#","/ep/pad/export/", $parsedUrl['path']);
			$schemes['classic-html'] = $parsedUrl['scheme'] . '://' . $parsedUrl['host'] . $parsedUrl['path'] . '?format=html';
		}
		else {
			$schemes['classic-html'] = $parsedUrl['scheme'] . '://' . $parsedUrl['host'] . '/' . 'ep/pad/export' . $parsedUrl['path'] . '/latest?format=html';
		}
		$schemes['lite-mediawiki'] = $parsedUrl['scheme'] . '://' . $parsedUrl['host'] . $parsedUrl['path'] . '/export/mediawiki';
		$schemes['lite-html'] = $parsedUrl['scheme'] . '://' . $parsedUrl['host'] . $parsedUrl['path'] . '/export/html';

		// now loop through them until we find a good one
		foreach ($schemes as $scheme => $url) {
			if ( $this->isGoodExportUrl( $url ) ) {
				return array('scheme' => $scheme, 'url' => $url);
			}
		}
		// if we get this far and don't have a valid url, return false
		$this->formErrors[] = array( 'importfrometherpad-novalidexporturl' );
		return false;
	}

	/**
	 * Takes a url and checks to see if it returns a good http status code.
	 *
	 * @param string $url 
	 * @return bool true if returned http status code is ok
	 */
	private function isGoodExportUrl( $url ) {
		$req = MWHttpRequest::factory( $url );
		$status = $req->execute();
		if ( $status->isOK() ) {
			return true;
		}
		else {
			$statusCode = $req->getStatus();
			return false;
		}
	}

	/** 
	 * Get contents returned by a url (etherpad export).
	 *
	 * @param string $url etherpad export url
	 * @return mixed bool false if retrieval failed, string returned page contents
	 *
	 */
	private function fetchContent( $url ) {
		$req = MWHttpRequest::factory( $url , array('followRedirects'=>true) );
		// execute request twice to ensure expected cookies are set
		$status = $req->execute();
		$cj = $req->getCookieJar();
		$status = $req->execute();
		if ( $status->isOK() ) {
			return $req->getContent();
		}
		else {
			$statusCode = $req->getStatus();
			return false;
		}
	}

	/**
	 * Convert html to mediawiki with pandoc.
	 *
	 * First tries fetching html export, saving to a temp file and running through pandoc.
	 * If that doesn't work, tries directly retreiving url with pandoc.
	 *
	 * Sets $this->content if successful.
	 *
	 * @param array $exportUrl
	 * @return bool true/false whether or not operation succeeded
	 */
	private function convertWithPandoc( $exportUrl ) {
		$returnVal = null;
		// @todo add check that pandoc exists
		// first try temp file method
		$tempfname = tempnam(sys_get_temp_dir(), 'import-');
		if ( $tempfname !== false ) {
			$tempContent = $this->fetchContent($exportUrl['url']);
			if ( $tempContent !== false ) {
				$fhandle = fopen($tempfname,'w');
				fwrite($fhandle, $tempContent);
				fclose($fhandle);
				$panDocCmd = $this->pathToPandoc . $this->pandocCmd . " -f html -t mediawiki " . $tempfname;
				$this->content = wfShellExec($panDocCmd, $returnVal);
				unlink($tempfname);
			}
		} else {
			// temp file method didn't work, try direct execution via url
			$panDocCmd = $this->pathToPandoc . $this->pandocCmd . " -f html -t mediawiki " . $exportUrl['url'];
			$this->content = wfShellExec($panDocCmd, $returnVal);
		}

		return $returnVal;
	}

	private function isPadPublic( $url ) {
		$req = MWHttpRequest::factory( $url );
		$status = $req->execute();
		$headers = $req->getResponseHeaders();

		while ( $req->isRedirect() ){
			// check to see if it's redirecting to a login
			// ep/account/sign-in is the url fragment if the pad isn't public
			// ep/pad/auth/ is fragment if pad has a password
			if ( preg_match( '/ep\/account\/sign-in/', $headers['location'][0] ) || preg_match( '/ep\/pad\/auth/', $headers['location'][0] ) ) {
				return false;
			}
			// grab the cookiejar
			$cj = $req->getCookieJar();
			// make new request
			// @todo is first location always right one?
			$req = MWHttpRequest::factory( $headers['location'][0] );
			// set the cookiejar
			$req->setCookieJar( $cj );
			// execute the request
			$status = $req->execute();
			// get new headers
			$headers = $req->getResponseHeaders();
		}
		// if we don't get a redirect to a sign-in page, assume it's public?
		// @todo investigate whether or not there is a better test for this
		return true;
	}

}


/* vim:set ts=4 sw=4 sts=4 noexpandtab: */
